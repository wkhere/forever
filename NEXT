+ elimination of multiple events after one edit
+ tick configurable via commandline

+ reuse .forever.step but ignore files selection

+ run processing also on start, like forever.sh

+ use rusage or sth to print:
  [0.49s user  0.05s sys  100.61% cpu  0.551s total]
  eg.
  cmd.ProcessState.SysUsage().(*syscall.Rusage) ...


- ability to restart the process (like webserver)

+ by default work on all files and dirs recursively minus
  some defined dirs [.git vendor __pycache__ .mypy_cache deps _build ebin ..etc]
  via filepath.Walk

+ when given dir argument, should chdir to there and try to read .forever.step
  from there

+ print rusage/maxrss only on unix systems
+ switch maxrss to int to support 32b architectures

+ on failed steps, the program is run twice;
+ next program should be only tried if last was not found

+ show timings also on failed processings runs (but when it was run)

+ somehow going to other directory misbehaves
  + chdir first and then add from .

+ improve usage message

- improve readme

+ flags: -d DIR, -v for verbose, -vv for debug (was -d)

+ regular argument is a command to run
  ~ if args are given, should be run on start, err/exit if not found in a path
    - now forever simply runs the given command on each change;
      a better solution is to check availability of that command once at start
      and do the same for default progs actually
  + if no arg is given, ./.forever.step and make are tried as until now

+ more with regard to the process logic:
  if the process exits with non-zero, should be noted also

+ unify vocabulary: program, not command

+ usage: show default programs

~ walk: ignore dirs on filesystems like /dev, /proc, /sys
  (checking for dev-like files doesn't make sense, as the dirs are walked and
   added, not the files)
  - differentiate these special filesystems by OS

- die on patho-situations, like: -d /, too many files to watch, ..etc

- extra: print watched dirs (after recursive walk+add) on some signal
